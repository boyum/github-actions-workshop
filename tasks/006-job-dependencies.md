# Lesson 4: Job Dependencies

Each job in a GitHub Actions workflow runs independently by default.
However, in many cases, you want to have jobs that depend on other jobs.
For example, you might want to run deployment only if the build and test jobs succeed.

To create dependencies between jobs, you can use the `needs` keyword.

There are a few reasons why you might want jobs to depend on other jobs:

- Run different jobs on different runners (e.g., build on Linux, test on Windows)
- Separate concerns (e.g., build, test, deploy)
- Speed up workflows by running jobs in parallel when possible

> [!TIP]
> If none of these reasons apply to your use case, consider combining the steps into a single job instead.

## Creating a Workflow with Job Dependencies

Let's create a workflow which posts a comment with information about test coverage.
To do that, we need two jobs:

1. A `test` job that runs tests
2. A `comment` job that posts a comment on the pull request with the test coverage

We can run the tests by using `npm run test:short-report`, which is already set up in this project.
It will run tests and output a short coverage report to the console.

The `comment` job should only run if the `test` job succeeds.

> [!TIP]
> You can use the [peter-evans/create-or-update-comment](https://github.com/marketplace/actions/create-or-update-comment) action to post comments on pull requests.

Here is an example of how the workflow file might look:

```yaml
name: Comment test coverage
on: 
  - pull_request

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Check out the code
        uses: actions/checkout@v5

      - name: Install dependencies
        run: npm install

      # Write test coverage output to a file
      - name: Run tests with coverage
        run: |
          npm run test:short-report > coverage-output.txt 2>&1

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage-output.txt
          retention-days: 1

  comment:
    # Wait for the 'test' job to complete
    needs: test

    runs-on: ubuntu-latest
    steps:
      # Download the coverage report artifact from the 'test' job,
      # storing it as a file on the runner
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report

      # Read the coverage report into memory
      - name: Read coverage report
        id: coverage
        run: |
          echo "COVERAGE_REPORT<<EOF" >> $GITHUB_OUTPUT
          cat coverage-output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post coverage comment
        uses: peter-evans/create-or-update-comment@v5
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            ## Test Coverage Report

            ```
            ${{ steps.coverage.outputs.COVERAGE_REPORT }}
            ```

            ---
            *Coverage report generated by GitHub Actions*
```

This workflow will run the `test` job first.
Then it will upload the test coverage report as an artifact.
If the tests pass, it will then run the `comment` job to post a comment on the pull request with the test coverage information.

## Task 1: Make the Comment Job More Robust

The above would work fine!
However, if we push another commit to the PR branch, the workflow will run again, and we will end up with multiple comments on the same PR.
We can avoid this by adding some logic to check for existing comments and update them instead of creating new ones.

Open the [comment-action](https://github.com/marketplace/actions/create-or-update-comment) documentation and see how they suggest using `peter-evans/find-comment` to find an existing comment to update.

> [!TIP]
> Use a unique identifier in the comment body to help find the comment later.
> For example, you can add `<!-- coverage-report -->` at the end of the comment body.
> Using a HTML comment (`<!-- -->`) ensures it won't be visible in the rendered comment.

## Task 2: Comparing test coverage in `main` and the current branch

Ok!
Now let's make the workflow a bit fancier.
We want to compare the test coverage in the current branch with the test coverage in the `main` branch.
This way, we can see if the coverage has increased or decreased.

> [!IMPORTANT]
> To compare coverage reports, we must use `npm run test:full-report` instead of `npm run test:short-report`!

To do this, in our workflow, we need to:

1. In one job, checkout the `main` branch and run the tests to get the coverage report for `main`.
2. In another job, checkout the current branch and run the tests to get the coverage report for the current branch.
3. Compare the coverage report from `main` with the coverage report from the current branch.
4. Post a comment with the comparison.
5. Update the comment if it already exists.

To compare the coverage reports, we can run `npm run compare-coverage-reports path/to/report1.txt path/to/report2.txt`, which is already set up in this project.

> [!TIP]
> `actions/checkout` supports checking out a specific branch using the `ref` option:
>
> ```yaml
>   uses: actions/checkout@v5
>   with:
>     ref: main
> ```
