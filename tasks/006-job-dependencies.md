# Lesson 4: Job Dependencies

Each job in a GitHub Actions workflow runs independently by default.
However, in many cases, you want to have jobs that depend on other jobs.
For example, you might want to run deployment only if the build and test jobs succeed.

To create dependencies between jobs, you can use the `needs` keyword.

There are a few reasons why you might want jobs to depend on other jobs:

- Run different jobs on different runners (e.g., build on Linux, test on Windows)
- Separate concerns (e.g., build, test, deploy)
- Speed up workflows by running jobs in parallel when possible

> [!TIP]
> If none of these reasons apply to your use case, consider combining the steps into a single job instead.

## Creating a Workflow with Job Dependencies

Let's create a workflow which posts a comment with information about test coverage.
To do that, we need two jobs:

1. A `test` job that runs tests
2. A `comment` job that posts a comment on the pull request with the test coverage

We can run the tests by using `npm test`, which is already set up in this project.

The `comment` job should only run if the `test` job succeeds.

> [!TIP]
> You can use the `actions/github-script` action to post comments on pull requests using JavaScript.

Here is an example of how the workflow file might look:

```yaml
name: Comment test coverage
on: 
  - pull_request

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Check out the code
        uses: actions/checkout@v5

      - name: Install dependencies
        run: npm install

      - name: Run tests with coverage
        run: |
          npm run test > coverage-output.txt 2>&1 || true


      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage-output.txt
          retention-days: 1

  comment:
    # Wait for the 'test' job to complete
    needs: test
    runs-on: ubuntu-latest
    steps:
      # Download the coverage report artifact from the 'test' job,
      # storing it as a file on the runner
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-report

      # Read the coverage report into memory
      - name: Read coverage report
        id: coverage
        run: |
          echo "COVERAGE_REPORT<<EOF" >> $GITHUB_OUTPUT
          cat coverage-output.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post comment with test coverage
        uses: actions/github-script@v8
        with:
          script: |
            const message = `## Test Coverage Report

                \`\`\`
                ${{ steps.coverage.outputs.COVERAGE_REPORT }}
                \`\`\`

                ---
                *Coverage report generated by GitHub Actions*`;

            // We need to find which issue or PR to comment on
            const issue_number = context.payload.pull_request.number;

            await github.issues.createComment({
              ...context.repo,
              issue_number,
              body: 
            });
```

This workflow will run the `test` job first.
Then it will upload the test coverage report as an artifact.
If the tests pass, it will then run the `comment` job to post a comment on the pull request with the test coverage information.

## Task 1: Make the Comment Job More Robust

The above would work fine!
However, if we push another commit to the PR branch, the workflow will run again, and we will end up with multiple comments on the same PR.
We can avoid this by adding some logic to check for existing comments and update them instead of creating new ones.

Instead, we can modify the `comment` job to use the [peter-evans/create-or-update-comment](https://github.com/marketplace/actions/create-or-update-comment) action, which simplifies this process.

Go ahead and update the `comment` job to use this action instead of `actions/github-script`.

## Task 2: Comparing test coverage in `main` and the current branch
